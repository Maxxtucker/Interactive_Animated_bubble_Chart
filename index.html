<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Bubble and Racing Bar Chart with Auto-Play and Filters</title>
    <!-- Include Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Include D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Include Font Awesome for icons (optional) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4C+6kJ2gBzdATja/wc95mGhgHvztm7FywX6bXqPq1k3NkNVfj5nWRxqX7C+ZKQzpZ2MBg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* General Styles */
        body {
            font-family: 'Open Sans', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }
        h1 {
            margin-top: 10px;
            color: #333;
        }
        /* Timeline Styles */
        #timeline {
            width: 90%;
            max-width: 1200px;
            margin: 10px auto;
            text-align: center;
            position: relative;
        }
        #play-button {
            position: absolute;
            top: 0;
            right: 0;
            margin-right: 10px;
            cursor: pointer;
            padding: 8px 16px;
            background-color: #eff1f3;
            color: rgb(14, 14, 14);
            border: none;
            border-radius: 4px;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        #play-button:hover {
            background-color: #7f8284;
        }
        /* Event Description Styles */
        #event-description {
            text-align: center;
            font-size: 16px;
            color: #555;
            margin-bottom: 20px;
        }
        /* Filter Container Styles */
        #filter-container {
            width: 95%;
            max-width: 1300px;
            margin: 20px auto;
            text-align: left;
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #filter-container h3 {
            margin-bottom: 15px;
            color: #333;
        }

        #filter-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        #filter-controls .buttons {
            display: flex;
            gap: 10px;
        }

        #filter-controls .buttons button {
            padding: 6px 12px;
            background-color: #eff1f3;
            color: rgb(14, 14, 14);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        #filter-controls .buttons button:hover {
            background-color: #7f8284;
        }

        #search-bar {
            flex-grow: 1;
            margin-right: 10px;
        }

        #search-bar input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        #company-filters {
            max-height: 70px; /* Increased height for better visibility */
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            background-color: #fdfdfd;
        }

        #company-filters label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            padding: 4px 8px;
            border-radius: 4px;
        }

        #company-filters label:hover {
            background-color: #e8edf1;
        }

        #company-filters input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
            transform: scale(1.2);
        }

        /* Charts Container Styles */
        #charts-container {
            display: flex;
            flex-wrap: wrap;
            width: 90%;
            max-width: 1400px;
            justify-content: space-between;
            margin-top: 20px;
        }
        #bubble-chart, #bar-chart {
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        #bubble-chart {
            width: 65%;
            max-width: 900px;
            height: 600px;
        }

        #bar-chart {
            width: 30%;
            max-width: 500px;
            height: 600px;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            #bubble-chart, #bar-chart {
                width: 48%;
            }
        }

        @media (max-width: 768px) {
            #charts-container {
                flex-direction: column;
                align-items: center;
            }
            #bubble-chart, #bar-chart {
                width: 100%;
                max-width: none;
            }
            #timeline svg {
                width: 100%;
            }
        }

        /* Loading Spinner Styles */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #2E86C1;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 6px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

    </style>
</head>
<body>

<h1>Company Performance Visualization</h1>

<div id="timeline">
    <button id="play-button"><i class="fas fa-play"></i> Play</button>
    <!-- Tooltip for play button -->
    <div class="tooltip" id="play-tooltip">Click to Play/Pause</div>
</div>

<!-- Add the filter container -->
<div id="filter-container">
    <h3>Filter Companies</h3>
    <div id="filter-controls">
        <div class="buttons">
            <button id="select-all"><i class="fas fa-check-square"></i> Select All</button>
            <button id="deselect-all"><i class="fas fa-square"></i> Deselect All</button>
        </div>
        <div id="search-bar">
            <input type="text" id="search-input" placeholder="Search companies...">
        </div>
    </div>
    <div id="company-filters">
        <!-- Checkboxes will be dynamically populated here -->
    </div>
</div>

<div id="charts-container">
    <div id="bubble-chart"></div>
    <div id="bar-chart"></div>
</div>

<!-- Tooltip Element -->
<div class="tooltip" id="chart-tooltip"></div>

<script>
// Your Google Sheets ID
const sheetId = '1XbkqyHqOWgcpZiScJIJDdPYyOJO1HaD1geFokMjC_ug';

// Sheet names for each table (Revenue Growth, EBITDA Margin, Revenue)
const sheetNames = {
    revenueGrowth: 'REVENUE GROWTH',
    ebitdaMargin: 'EBITDA MARGIN',
    revenue: 'REVENUE'
};

// Company logos mapping
const companyLogos = {
    "ABNB": "/logos/ABNB_logo.png",
    "BKNG": "/logos/BKNG_logo.png",
    "EXPE": "/logos/EXPE_logo.png",
    "TCOM": "/logos/TCOM_logo.png",
    "TRIP": "/logos/TRIP_logo.png",
    "TRVG": "/logos/TRVG_logo.png",
    "EDR": "/logos/EDR_logo.png",
    "DESP": "/logos/DESP_logo.png",
    "MMYT": "/logos/MMYT_logo.png",
    "Ixigo": "/logos/IXIGO_logo.png",
    "SEERA": "/logos/SEERA_logo.png",
    "Webjet": "/logos/WEB_logo.png",
    "LMN": "/logos/LMN_logo.png",
    "Yatra": "/logos/YTRA_logo.png",
    "Orbitz": "/logos/OWW_logo.png",
    "Travelocity": "/logos/Travelocity_logo.png",
    "EaseMyTrip": "/logos/EASEMYTRIP_logo.png",
    // Add other company logos here...
};

// Raw color dictionary with potential leading/trailing spaces
const color_dict_raw = {
    'ABNB': '#ff5895',
    'Almosafer': '#bb5387',
    'BKNG': '#003480',
    'DESP': '#755bd8',
    'EXPE': '#fbcc33',
    'EASEMYTRIP': '#00a0e2',
    'Ixigo': '#e74c3c',
    'MMYT': '#e74c3c',
    'TRIP': '#00af87',
    'TRVG': '#e74c3c',
    'Wego': '#4e843d',
    'Yatra': '#e74c3c',
    'TCOM': '#2577e3',
    'EDR': '#2577e3',
    'LMN': '#fc03b1',
    'Webjet': '#e74c3c',
    'SEERA': '#750808',
    'PCLN': '#003480',
    'Orbitz': '#8edbfa',
    'Travelocity': '#1d3e5c',
};

// Function to clean the color dictionary by trimming keys
function cleanColorDict(rawDict) {
    const cleanedDict = {};
    for (const [key, value] of Object.entries(rawDict)) {
        const cleanKey = key.trim();
        cleanedDict[cleanKey] = value;
    }
    return cleanedDict;
}

// Cleaned color dictionary without leading/trailing spaces
const color_dict = cleanColorDict(color_dict_raw);

// Function to fetch CSV data from Google Sheets and convert to JSON-like objects
function fetchSheetData(sheetName) {
    const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheetName)}`;
    return fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`Network response was not ok for sheet: ${sheetName}`);
            }
            return response.text();
        })
        .then(csvText => csvToObjects(csvText, sheetName))
        .catch(error => {
            console.error(`Error fetching sheet ${sheetName}:`, error);
            return [];
        });
}

// Function to parse CSV data into a usable array of objects
function csvToObjects(csvText, sheetName) {
    const lines = csvText.split("\n").filter(line => line.trim() !== "");
    if (lines.length === 0) {
        console.warn(`Sheet ${sheetName} is empty.`);
        return [];
    }
    const headers = lines[0].split(",").map(header => header.trim().replace(/['"]+/g, ''));
    const companies = headers.slice(1);
    const data = [];
    lines.slice(1).forEach(line => {
        const cleanedLine = line.replace(/(\d+),(\d+)/g, '$1$2'); // Remove commas in numbers
        const values = cleanedLine.split(",");
        const quarter = values[0] ? values[0].trim().replace(/['"]+/g, '') : null;
        if (!quarter) return;
        values.slice(1).forEach((value, i) => {
            if (value && companies[i]) {
                const cleanedValue = value.trim().replace(/['"$%]+/g, '');
                const parsedValue = parseFloat(cleanedValue);
                if (isNaN(parsedValue)) return;
                data.push({
                    sheetName,
                    company: companies[i].trim().replace(/['"]+/g, ''),
                    quarter: quarter,
                    value: parsedValue
                });
            }
        });
    });
    return data;
}

// Function to merge data from the three sheets
function mergeData(revenueGrowth, ebitdaMargin, revenue) {
    const merged = [];
    revenueGrowth.forEach(growth => {
        const company = growth.company;
        const quarter = growth.quarter;
        const ebitda = ebitdaMargin.find(e => e.company === company && e.quarter === quarter);
        const rev = revenue.find(r => r.company === company && r.quarter === quarter);
        if (ebitda && rev) {
            merged.push({
                company,
                quarter,
                revenueGrowth: growth.value,
                ebitdaMargin: ebitda.value,
                revenue: rev.value
            });
        }
    });
    return merged;
}

// Declare global variables
let maxRevenueValue;
let isPlaying = false;
let playInterval;
let currentQuarterIndex = 0;
let uniqueQuarters;
let mergedData;
let timelineTriangle;
let xScaleTimeline;
let timelineHeight = 80; // Global height variable
let uniqueYears;
let yearIndices;
let selectedCompanies = []; // Initialize empty, will be set later

// Function to initialize company filters
function initializeCompanyFilters(sheetData) {
    const companies = [...new Set(sheetData.map(d => d.company))].sort();
    const filterContainer = d3.select("#company-filters");

    // Clear any existing filters
    filterContainer.html('');

    companies.forEach(company => {
        const id = `filter-${company}`;

        const label = filterContainer.append("label").attr("for", id);
        label.append("input")
            .attr("type", "checkbox")
            .attr("id", id)
            .attr("value", company)
            .property("checked", true) // Initially all checked
            .on("change", handleFilterChange);
        label.append("span").text(company);
    });

    // Initialize selectedCompanies with all companies
    selectedCompanies = companies;
}

// Function to handle filter changes
function handleFilterChange() {
    const searchTerm = d3.select("#search-input").property("value").toLowerCase();

    const checkedBoxes = d3.selectAll("#company-filters input[type='checkbox']")
        .nodes()
        .filter(d => d.checked && d.value.toLowerCase().includes(searchTerm))
        .map(d => d.value);

    selectedCompanies = checkedBoxes;

    // If no companies are selected, optionally handle it (e.g., show a message)
    if (selectedCompanies.length === 0) {
        console.warn("No companies selected. Charts will be empty.");
    }

    // Update the charts based on selected companies
    const selectedQuarter = uniqueQuarters[currentQuarterIndex];
    updateBubbleChart(selectedQuarter, mergedData);
    updateBarChart(selectedQuarter, mergedData);
}

// Function to create the interactive timeline using D3.js
function createTimeline(quarters, mergedData, yearIndices, uniqueYears) {
    const width = document.getElementById('timeline').clientWidth;
    const height = timelineHeight; // Use the global variable
    const svg = d3.select("#timeline").append("svg")
        .attr("width", width)
        .attr("height", height);
    
    // Define the linear scale for the timeline
    xScaleTimeline = d3.scaleLinear()
        .domain([0, quarters.length - 1])
        .range([50, width - 50]);
    
    // Define tick values for every quarter
    const allTickValues = d3.range(0, quarters.length);
    
    // Define the tick format to show year labels only for Q1
    const axisBottom = d3.axisBottom(xScaleTimeline)
        .tickValues(allTickValues) // Set tick positions to all quarters
        .tickFormat(d => {
            if (yearIndices.includes(d)) {
                // Find the index of the year and return the corresponding year label
                const yearLabel = uniqueYears[yearIndices.indexOf(d)];
                return yearLabel;
            }
            return ''; // No label for other quarters
        });
    
    // Append the x-axis to the SVG
    svg.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0, ${height - 30})`)
        .call(axisBottom)
        .selectAll("text")
        .attr("transform", "rotate(0)") // No rotation needed for year labels
        .style("text-anchor", "middle"); // Center the text
    
    // Differentiate tick lengths: longer for years (Q1), shorter for other quarters
    svg.selectAll(".x-axis .tick line")
        .attr("y2", d => yearIndices.includes(d) ? 8 : 4) // Longer ticks for Q1
        .attr("stroke", "#000"); // Same color; adjust if needed
    
    // Define the path for the triangle indicator
    const trianglePath = d3.symbol().type(d3.symbolTriangle).size(200);
    
    // Define the drag behavior
    const drag = d3.drag()
        .on("drag", function (event) {
            if (isPlaying) return; // Disable dragging while playing

            // Calculate the constrained x position
            let x = Math.min(Math.max(50, event.x), width - 50);

            // Update the triangle's position (transform) based on the new x
            d3.select(this)
                .attr("transform", `translate(${x}, ${height / 2}) rotate(180)`); // Keep triangle upside down

            // Calculate the closest quarter index based on x position
            const index = Math.round(xScaleTimeline.invert(x));
            if (index >= 0 && index < quarters.length) {
                currentQuarterIndex = index;
                const selectedQuarter = quarters[index];
                updateBubbleChart(selectedQuarter, mergedData);
                updateBarChart(selectedQuarter, mergedData);
            }
    });
    
    // Create the triangle and make it draggable
    timelineTriangle = svg.append("path")
        .attr("d", trianglePath)
        .attr("transform", `translate(${xScaleTimeline(0)}, ${height / 2}) rotate(180)`) // Start at the beginning, upside down
        .attr("fill", "#7f8284")
        .attr("stroke", "#000")
        .attr("stroke-width", 1)
        .call(drag);

    // Make the timeline responsive on window resize
    window.addEventListener('resize', () => {
        const newWidth = document.getElementById('timeline').clientWidth;
        svg.attr("width", newWidth);
        xScaleTimeline.range([50, newWidth - 50]);
        svg.select(".x-axis")
            .call(axisBottom.scale(xScaleTimeline));

        // Update triangle position
        const newX = xScaleTimeline(currentQuarterIndex);
        timelineTriangle
            .attr("transform", `translate(${newX}, ${height / 2}) rotate(180)`);
    });
}

// Function to update the timeline triangle position
function updateTimelineTriangle(index) {
    const width = document.getElementById('timeline').clientWidth;
    xScaleTimeline.range([50, width - 50]);
    const x = xScaleTimeline(index);
    timelineTriangle
        .transition() // Add a smooth transition
        .duration(300)
        .attr("transform", `translate(${x}, ${timelineHeight / 2}) rotate(180)`); // Use global height
}

// Function to update the bubble chart
function updateBubbleChart(quarter, sheetData) {
    // Filter data for the selected quarter and selected companies
    const quarterData = sheetData.filter(d => d.quarter === quarter && selectedCompanies.includes(d.company));
    if (quarterData.length === 0) {
        Plotly.react('bubble-chart', [], { title: `No data available for ${quarter}` });
        return;
    }

    // Prepare the bubble data
    const bubbleData = [{
        x: quarterData.map(d => d.ebitdaMargin),
        y: quarterData.map(d => d.revenueGrowth),
        text: quarterData.map(d => d.company),
        mode: 'markers',
        marker: {
            size: quarterData.map(d => Math.sqrt(Math.abs(d.revenue))),
            color: quarterData.map(d => color_dict[d.company] || 'gray'), // Assign colors based on color_dict
            sizemode: 'area',
            sizeref: 2.0 * Math.max(...quarterData.map(d => Math.sqrt(Math.abs(d.revenue)))) / (40**2),
            sizemin: 4
        },
        customdata: quarterData.map(d => d.company), // Add company symbol as customdata
        hoverinfo: 'text+x+y+marker.size',
        hovertext: quarterData.map(d => `${d.company}<br>Revenue Growth: ${d.revenueGrowth}%<br>EBITDA Margin: ${d.ebitdaMargin}%<br>Revenue: $${d3.format(",")(d.revenue)}M`)
    }];

    // Prepare images for each company
    const images = quarterData.map(d => {
        const logoPath = companyLogos[d.company];
        if (!logoPath) return null; // Skip if no logo defined
        return {
            source: logoPath,
            xref: 'x',
            yref: 'y',
            x: d.ebitdaMargin,
            y: d.revenueGrowth + 4, // Offset y to position the logo above the bubble
            sizex: 10,
            sizey: 10,
            xanchor: 'center',
            yanchor: 'bottom',
            layer: 'above',
            sizing: 'contain', // Ensure the entire logo fits within the specified size
            opacity: 0.8
        };
    }).filter(img => img !== null); // Remove nulls

    // Define the layout with images
    const layout = {
        title: `Revenue Growth vs EBITDA Margin for ${quarter}`,
        xaxis: { title: 'EBITDA Margin (%)', range: [-50, 50], gridcolor: '#eee' },
        yaxis: { title: 'Revenue Growth (%)', range: [-30, 100], gridcolor: '#eee' },
        margin: { t: 60, l: 80, r: 80, b: 60 },
        images: images,
        showlegend: false,
        hovermode: 'closest'
    };

    // Render the bubble chart with images
    Plotly.react('bubble-chart', bubbleData, layout, {responsive: true});
}


// Function to update the racing bar chart using D3.js
function updateBarChart(quarter, sheetData) {
    // Filter data for the selected quarter and selected companies
    const quarterData = sheetData.filter(d => d.quarter === quarter && selectedCompanies.includes(d.company))
        .sort((a, b) => b.revenue - a.revenue);

    // If SVG doesn't exist, create it
    let svg = d3.select("#bar-chart").select("svg");
    if (svg.empty()) {
        const width = document.getElementById('bar-chart').clientWidth;
        const height = document.getElementById('bar-chart').clientHeight;
        const margin = { top: 30, right: 20, bottom: 50, left: 150 };

        svg = d3.select("#bar-chart").append("svg")
            .attr("width", width)
            .attr("height", height);

        svg.append("g").attr("class", "x-axis");
        svg.append("g").attr("class", "y-axis");
        
        // Append a group for bar labels
        svg.append("g").attr("class", "bar-labels");

        // Make the bar chart responsive on window resize
        window.addEventListener('resize', () => {
            const newWidth = document.getElementById('bar-chart').clientWidth;
            const newHeight = document.getElementById('bar-chart').clientHeight;
            svg.attr("width", newWidth).attr("height", newHeight);

            // Update scales and axes
            const updatedX = d3.scaleLinear()
                .domain([0, maxRevenueValue])
                .range([margin.left, newWidth - margin.right]);

            const updatedY = d3.scaleBand()
                .domain(quarterData.map(d => d.company))
                .range([margin.top, newHeight - margin.bottom])
                .padding(0.1);

            svg.select(".x-axis")
                .attr("transform", `translate(0,${newHeight - margin.bottom})`)
                .call(d3.axisBottom(updatedX).ticks(5).tickFormat(d3.format("$.2s")));

            svg.select(".y-axis")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(updatedY));

            // Update bars
            svg.selectAll(".bar")
                .attr("x", updatedX(0))
                .attr("y", d => updatedY(d.company))
                .attr("height", updatedY.bandwidth())
                .attr("width", d => updatedX(d.revenue) - updatedX(0));

            // Update labels
            svg.selectAll(".bar-label")
                .attr("x", d => updatedX(d.revenue) + 5)
                .attr("y", d => updatedY(d.company) + updatedY.bandwidth() / 2);
        });
    }

    const width = parseInt(svg.attr("width"));
    const height = parseInt(svg.attr("height"));
    const margin = { top: 30, right: 20, bottom: 50, left: 65 };

    // Use the precomputed maximum revenue value for the x-axis domain
    const x = d3.scaleLinear()
        .domain([0, maxRevenueValue])
        .range([margin.left, width - margin.right]);

    const y = d3.scaleBand()
        .domain(quarterData.map(d => d.company))
        .range([margin.top, height - margin.bottom])
        .padding(0.1);

    // svg.select(".x-axis")
    //     .attr("transform", `translate(0,${height - margin.bottom})`)
    //     .transition()
    //     .duration(500)
    //     .call(d3.axisBottom(x).ticks(5).tickFormat(d3.format("$.2s")))
    //     .selectAll("text")
    //     .attr("transform", "rotate(-45)")
    //     .style("text-anchor", "end");

    svg.select(".y-axis")
        .attr("transform", `translate(${margin.left},0)`)
        .transition()
        .duration(500)
        .call(d3.axisLeft(y));

    const bars = svg.selectAll(".bar")
        .data(quarterData, d => d.company);

    // Update existing bars
    bars.transition()
        .duration(500)
        .attr("x", x(0))
        .attr("y", d => y(d.company))
        .attr("height", y.bandwidth())
        .attr("width", d => x(d.revenue) - x(0))
        .style("fill", d => color_dict[d.company] || '#2E86C1'); // Assign colors based on color_dict

    // Enter new bars
    bars.enter().append("rect")
        .attr("class", "bar")
        .attr("x", x(0))
        .attr("y", d => y(d.company))
        .attr("height", y.bandwidth())
        .attr("width", d => x(d.revenue) - x(0))
        .style("fill", d => color_dict[d.company] || '#2E86C1') // Assign colors based on color_dict
        .on("mouseover", function(event, d) {
            d3.select(this).style("fill", d3.rgb(color_dict[d.company] || '#2E86C1').darker(1));
            showTooltip(event, `${d.company}<br>Revenue: $${d3.format(",")(d.revenue)}M`);
        })
        .on("mousemove", function(event) {
            moveTooltip(event);
        })
        .on("mouseout", function(event, d) {
            d3.select(this).style("fill", color_dict[d.company] || '#2E86C1');
            hideTooltip();
        });

    // Remove old bars
    bars.exit()
        .transition()
        .duration(500)
        .attr("width", 0)
        .remove();

    // ----- Adding Revenue Labels -----
    
    // Select all labels and bind data
    const labels = svg.selectAll(".bar-label")
        .data(quarterData, d => d.company);

    // Remove old labels
    labels.exit()
        .transition()
        .duration(500)
        .attr("x", x(0))
        .remove();

    // Update existing labels
    labels.transition()
        .duration(500)
        .attr("x", d => x(d.revenue) + 5) // Position label 5px to the right of the bar
        .attr("y", d => y(d.company) + y.bandwidth() / 2)
        .text(d => d3.format("$.2s")(d.revenue));

    // Enter new labels
    labels.enter().append("text")
        .attr("class", "bar-label")
        .attr("x", d => x(d.revenue) + 5) // Position label 5px to the right of the bar
        .attr("y", d => y(d.company) + y.bandwidth() / 2)
        .attr("dy", ".35em") // Vertically center the text
        .attr("font-size", "12px")
        .attr("fill", "black") // Text color; adjust if needed
        .text(d => d3.format("$.2s")(d.revenue))
        .on("mouseover", function(event, d) {
            showTooltip(event, `${d.company}<br>Revenue: $${d3.format(",")(d.revenue)}M`);
        })
        .on("mousemove", function(event) {
            moveTooltip(event);
        })
        .on("mouseout", function(event, d) {
            hideTooltip();
        });
}

// Function to handle the Play/Pause button
function handlePlayPause() {
    const playButton = document.getElementById('play-button');
    const playIcon = playButton.querySelector('i');
    if (isPlaying) {
        // Pause the auto-play
        clearInterval(playInterval);
        playButton.textContent = '';
        playButton.appendChild(playIcon);
        playButton.appendChild(document.createTextNode(' Play'));
        isPlaying = false;
    } else {
        // Start the auto-play
        playButton.textContent = '';
        playButton.appendChild(playIcon);
        playButton.appendChild(document.createTextNode(' Pause'));
        isPlaying = true;
        playInterval = setInterval(() => {
            currentQuarterIndex = (currentQuarterIndex + 1) % uniqueQuarters.length;
            const selectedQuarter = uniqueQuarters[currentQuarterIndex];
            
            // Update the position of the triangle on the timeline
            updateTimelineTriangle(currentQuarterIndex);
            
            // Update the bubble and bar charts based on selected companies
            updateBubbleChart(selectedQuarter, mergedData);
            updateBarChart(selectedQuarter, mergedData);
        }, 500); // Adjusted interval to accommodate transition durations
    }
}

// Tooltip Functions
const tooltip = d3.select("#chart-tooltip");

function showTooltip(event, content) {
    tooltip
        .html(content)
        .style("left", (event.pageX + 15) + "px")
        .style("top", (event.pageY - 28) + "px")
        .transition()
        .duration(200)
        .style("opacity", .9);
}

function moveTooltip(event) {
    tooltip
        .style("left", (event.pageX + 15) + "px")
        .style("top", (event.pageY - 28) + "px");
}

function hideTooltip() {
    tooltip
        .transition()
        .duration(500)
        .style("opacity", 0);
}

// Search Functionality for Filters
d3.select("#search-input").on("input", function() {
    const searchTerm = this.value.toLowerCase();
    d3.selectAll("#company-filters label")
        .style("display", d => {
            const company = d3.select(d).select("input").attr("value").toLowerCase();
            return company.includes(searchTerm) ? "flex" : "none";
        });
});

// Select All and Deselect All Button Functions
d3.select("#select-all").on("click", () => {
    d3.selectAll("#company-filters input[type='checkbox']")
        .property("checked", true)
        .each(function() {
            const company = this.value;
            if (!selectedCompanies.includes(company)) {
                selectedCompanies.push(company);
            }
        });
    updateBubbleChart(uniqueQuarters[currentQuarterIndex], mergedData);
    updateBarChart(uniqueQuarters[currentQuarterIndex], mergedData);
});

d3.select("#deselect-all").on("click", () => {
    d3.selectAll("#company-filters input[type='checkbox']")
        .property("checked", false);
    selectedCompanies = [];
    updateBubbleChart(uniqueQuarters[currentQuarterIndex], mergedData);
    updateBarChart(uniqueQuarters[currentQuarterIndex], mergedData);
});

// Initialize Tooltip for Play Button
const playTooltip = d3.select("#play-tooltip");

d3.select("#play-button")
    .on("mouseover", function() {
        playTooltip
            .style("opacity", 1)
            .style("left", (d3.event.pageX + 10) + "px")
            .style("top", (d3.event.pageY - 10) + "px")
            .text(isPlaying ? "Click to Pause" : "Click to Play");
    })
    .on("mousemove", function(event) {
        playTooltip
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px");
    })
    .on("mouseout", function() {
        playTooltip
            .style("opacity", 0);
    });

// Event listener for the Play/Pause button
document.getElementById('play-button').addEventListener('click', handlePlayPause);

// Fetch data from all three sheets (Revenue Growth, EBITDA Margin, Revenue)
Promise.all([
    fetchSheetData(sheetNames.revenueGrowth),
    fetchSheetData(sheetNames.ebitdaMargin),
    fetchSheetData(sheetNames.revenue)
]).then(([revenueGrowthData, ebitdaMarginData, revenueData]) => {
    mergedData = mergeData(revenueGrowthData, ebitdaMarginData, revenueData);
    uniqueQuarters = [...new Set(mergedData.map(d => d.quarter))].sort(); // Ensure chronological order
    console.log("Unique Quarters after merge:", uniqueQuarters);

    if (uniqueQuarters.length === 0) {
        console.error("No quarters available in the merged data.");
        d3.select("#charts-container").html("<p>No data available to display.</p>");
        return;
    }

    // Extract unique years based on the quarter format "1998Q1"
    uniqueYears = [...new Set(uniqueQuarters.map(q => {
        if (typeof q === "string") {
            const match = q.match(/^(\d{4})Q([1-4])$/);
            if (match) {
                return match[1]; // Extract year before 'Q'
            } else {
                console.warn("Unexpected quarter format:", q);
                return "";
            }
        } else {
            console.warn("Unexpected quarter format:", q);
            return "";
        }
    }))].filter(year => year !== "");
    console.log("Unique Years:", uniqueYears);

    // Find the index of Q1 for each year
    yearIndices = uniqueQuarters.reduce((acc, q, i) => {
        if (typeof q === "string") {
            const match = q.match(/^(\d{4})Q([1-4])$/);
            if (match) {
                const quarter = "Q" + match[2];
                if (quarter === "Q1") acc.push(i);
            } else {
                console.warn("Unexpected quarter format:", q);
            }
        } else {
            console.warn("Unexpected quarter format:", q);
        }
        return acc;
    }, []);
    console.log("Year Indices:", yearIndices);

    if (uniqueYears.length === 0 || yearIndices.length === 0) {
        console.error("Failed to extract unique years or year indices.");
        d3.select("#charts-container").html("<p>Insufficient data to display.</p>");
        return;
    }

    // Compute the maximum revenue value across all data
    maxRevenueValue = d3.max(mergedData, d => d.revenue);
    console.log("Max Revenue Value:", maxRevenueValue);

    // Initialize the company filter UI and selectedCompanies
    initializeCompanyFilters(mergedData);

    // Create the timeline
    createTimeline(uniqueQuarters, mergedData, yearIndices, uniqueYears);

    // Initialize the charts with all companies selected
    updateBubbleChart(uniqueQuarters[0], mergedData);
    updateBarChart(uniqueQuarters[0], mergedData);
}).catch(error => {
    console.error("Error fetching or processing data: ", error);
    d3.select("#charts-container").html("<p>Error loading data. Please try again later.</p>");
});
</script>

</body>
</html>
